extends Object

class_name TemplateGodot4


var text = """extends Node

signal data_recieved(data, type)
signal timeout(type)

enum WAIT_FOR {
	NOTHING,
	HIGHSCORE_FOR_PLAYER,
	HIGHSCORE_FOR_PLACES,
	SUBMISSION_INFO,
	PLAYER_DATA
}


# set in config file under [Highscore]
var public_key = "[[[public_key]]]"
var low_wins = [[[low_wins]]]

var host = "https://www.kitchen-games.de/leaderboard"

#the score file is encrypted to prevent cheating
var highscore_file = "user://encrypted_score.json"

# the key to encrypt the highscore file and the score submitted to the server
# is has to be exactly 16 chars and the same as configured for the board on the server
var encryption_key = "[[[encryption_key]]]"
@onready var aes = AESContext.new()

# the private key is generated by the server and gets saved here when you submit a score the first time
var private_key_file = "user://private_key.json"
var private_key = null
var player_id = null

# loading from score file
var player_name = null

var config_file_path = "res://config.cfg"

var adjectives = ["sweet","cute","sassy","giant","neat","hot","small","lumpy","clean","lucky","drunk","nice","huge","shiny","icy","juicy","crazy","new","bored","messy","silly","fancy","hard","solid","slimy","flashy","pretty","boring","odd","ill","easy","grumpy","cuddly","mixed","red","green","blue","purple","golden","yellow","orange","tiny","tense","brave","narrow","first","young","old","jazzy","wise"]
var nouns = ["stranger","tomato","buyer","cousin","orange","bread","error","mum","dad","virus","salad","dragon","actor","mom","girl","pie","lady","guy","cheese","pizza","user","engine","wife","singer","coffee","potato","tea","basket","steak","man","woman","death","breath","sir","king","queen","tomato","insect","hair","honey","person","writer"]

var http_request
var waiting_for = WAIT_FOR.NOTHING
var time_out_timer

@onready var json = JSON.new()


func _ready():
	load_config()
	
	time_out_timer = Timer.new()
	time_out_timer.wait_time = 3
	time_out_timer.timeout.connect(on_timeout)
	add_child(time_out_timer)
	http_request = HTTPRequest.new()
	http_request.request_completed.connect(_on_request_completed)
	data_recieved.connect(_on_data_recieved)
	add_child(http_request)
	
	
	if !FileAccess.file_exists(highscore_file):
		make_local_highscore_file()
		
	if !FileAccess.file_exists(private_key_file):
		save_private_key(null, null)
		
	player_name = load_player_name()
	private_key = load_private_key()
	player_id = load_player_id()
	
	if load_local_highscore():
		#if there is something to sync please do so
		sync_global_score()
	
	

func load_config():
	var config = ConfigFile.new()
	config.load(config_file_path)
	
	public_key = config.get_value("Highscore", "public_key", public_key)
	host = config.get_value("Highscore", "host", host)
	nouns = config.get_value("Highscore", "nouns", nouns)
	adjectives = config.get_value("Highscore", "adjectives", adjectives)
	encryption_key = config.get_value("Highscore", "encryption_key", encryption_key)
	
	
func _on_request_completed(_result, response_code, _headers, body):
	if response_code != 200 or waiting_for == WAIT_FOR.NOTHING:
		return
	json.parse(body.get_string_from_utf8())
	emit_signal("data_recieved", json.data, waiting_for)
	time_out_timer.stop()
	waiting_for = WAIT_FOR.NOTHING
	
	
func on_timeout():
	emit_signal("timeout", waiting_for)

# function to synch the global and the local score, in case the highscore was beaten when playing online
func sync_global_score():
	submit_highscore(load_local_highscore())
	
	

# local highscore administration
func load_player_name():
	var file = FileAccess.open_encrypted_with_pass(highscore_file, FileAccess.READ, encryption_key)
	if !file:
		print("error opening highscore file")
		return 
	json.parse(file.get_as_text())
	var data = json.data
	return data.player_name
	

func load_local_highscore():
	var file = FileAccess.open_encrypted_with_pass(highscore_file, FileAccess.READ, encryption_key)
	if !file:
		print("error opening highscore file")
		return 
	json.parse(file.get_as_text())
	var data = json.data
	return data.highscore
	
	
func save_local_highscore(score, initial = false):
	# just save the local highscore if its actually better than the last. else return
	if load_local_highscore() != null and (low_wins && score >= load_local_highscore() or !low_wins && score <= load_local_highscore()):
		return
	var file = FileAccess.open_encrypted_with_pass(highscore_file, FileAccess.WRITE, encryption_key)
	if !file:
		print("Error opening file")
		return

	file.store_line(json.stringify({"player_name": player_name, "highscore": score}))
	file.close()

# private_key administration
func save_private_key(player_id, private_key):
	var file = FileAccess.open(private_key_file, FileAccess.WRITE)
	if !file:
		print("Error opening file")
		return

	file.store_line(json.stringify({"player_id": player_id, "private_key": private_key}))
	file.close()


func load_private_key():
	var file = FileAccess.open(private_key_file, FileAccess.READ)
	json.parse(file.get_as_text())
	var data = json.data
	return data.private_key


func load_player_id():
	var file = FileAccess.open(private_key_file, FileAccess.READ)
	json.parse(file.get_as_text())
	var data = json.data
	return data.player_id
	
	
func generate_player_name():
	randomize()
	return adjectives[randi() % adjectives.size()] + " and " + adjectives[randi() % adjectives.size()] + " " + nouns[randi() % nouns.size()]


func make_local_highscore_file():
	player_name = generate_player_name()
	var file = FileAccess.open_encrypted_with_pass(highscore_file, FileAccess.WRITE, encryption_key)
	if !file:
		print("Error opening file")
		return

	file.store_line(json.stringify({"player_name": player_name, "highscore": null}))
	file.close()


func get_highscore_for_player(_player_id, before = 0, after = 0):
	var url = host + "/get_entry.php?public_key=" + str(public_key)  + "&player_id=" + _player_id + "&before=" + str(before) + "&after=" + str(after)
	http_request.cancel_request()
	var _err = http_request.request(url)
	waiting_for = WAIT_FOR.HIGHSCORE_FOR_PLAYER
	time_out_timer.start()
	
	
func get_highscore_for_places(from, to):
	from = max(from, 1)
	var url = host + "/get_entries.php?public_key=" + str(public_key)  + "&from=" + str(from) + "&to=" + str(to)
	http_request.cancel_request()
	var _err = http_request.request(url)
	waiting_for = WAIT_FOR.HIGHSCORE_FOR_PLACES
	time_out_timer.start()
	
	
func submit_highscore(highscore):
	http_request.cancel_request()
	
	var encrypted_highscore = encrypt_score(highscore)
	var url
	if private_key && player_id:
		url = str(host + "/submit_entry.php?public_key=" + str(public_key) + "&private_key=" + str(private_key) + "&player_id=" + str(player_id) + "&score=" + str(encrypted_highscore))
		waiting_for = WAIT_FOR.SUBMISSION_INFO
	else:
		url = str(host + "/add_player_and_submit_entry.php?public_key=" + str(public_key) + "&name=" + player_name.uri_encode() + "&score=" + str(encrypted_highscore))
		waiting_for = WAIT_FOR.PLAYER_DATA
	var _err = http_request.request(url, ["User-Agent: Pirulo/1.0 (Godot)","Accept: */*"], HTTPClient.METHOD_GET)


func _on_data_recieved(data, data_type):
	match data_type:
		WAIT_FOR.PLAYER_DATA:
			if data.ok && data.private_key && data.player_id:
				save_private_key(data.player_id, data.private_key)
				private_key = load_private_key()
				player_id = load_player_id()
				

func encrypt_score(score):
	aes.start(AESContext.MODE_ECB_ENCRYPT, encryption_key.to_utf8_buffer())
	var highscore_array = str(score).to_utf8_buffer()
	var padding = 16 - (highscore_array.size() % 16)
	for i in range(padding):
		highscore_array.append(padding)
	
	var encrypted_highscore = pool_byte_array_to_byte_string(aes.update(highscore_array))
	aes.finish()
	return encrypted_highscore
	
func pool_byte_array_to_byte_string(array):
	var string = ""
	for byte in array:
		string += str(byte)
		string += "_"
	
	return string
"""
